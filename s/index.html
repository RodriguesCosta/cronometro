<!doctype html>
<html lang="pt-BR">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Cronômetro Regressivo</title>
		<style>
			:root {
				color-scheme: dark;
			}
			html, body {
				height: 100%;
				margin: 0;
			}
			body {
				background: #000;
				color: #fff;
				display: grid;
				place-items: center;
				font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
				user-select: none;
				-webkit-tap-highlight-color: transparent;
			}
			#wrap {
				text-align: center;
				width: 100%;
			}
			#time {
				font-variant-numeric: tabular-nums; /* uniform width digits */
				letter-spacing: 0.02em;
				line-height: 1;
				/* responsive sizing */
				font-size: clamp(48px, 18vw, 180px);
			}
			#hint {
				margin-top: 1rem;
				opacity: 0.5;
				font-size: clamp(12px, 2.8vw, 16px);
			}
			.hidden { display: none; }
		</style>
	</head>
	<body>
		<div id="wrap">
			<div id="time">00:00:000</div>
			<div id="hint">Clique para reiniciar</div>
		</div>

		<script>
			(function () {
				// Fator de desaceleração: minutos/segundos passam % mais devagar => 0.85x do tempo real
				const SPEED_FACTOR = 0.80;

				const timeEl = document.getElementById('time');
				const hintEl = document.getElementById('hint');

				let totalMs = 0; // duração escolhida (em ms) em "tempo exibido"
				let startReal = 0; // performance.now() quando começou
				let rafId = null;
				let running = false;
				let wakeLock = null; // Screen Wake Lock handle
				const wakeSupported = 'wakeLock' in navigator;

				async function requestWakeLock() {
					if (!wakeSupported) return;
					try {
						// Algumas plataformas exigem gesto do usuário. Tente sempre que iniciar/voltar ao app.
						wakeLock = await navigator.wakeLock.request('screen');
						wakeLock.addEventListener('release', () => {
							// Wake Lock liberado (por sistema ou manualmente)
						});
					} catch (err) {
						// Pode falhar se o navegador não permitir ou se não houver gesto do usuário
						// console.debug('Falha ao solicitar Wake Lock:', err);
					}
				}

				async function releaseWakeLock() {
					try {
						if (wakeLock) {
							await wakeLock.release();
							wakeLock = null;
						}
					} catch (_) {}
				}

				function pad(num, size) {
					let s = String(num);
					while (s.length < size) s = '0' + s;
					return s;
				}

				function askMinutes() {
					// Mostra uma instrução rápida e depois pede o valor
					alert('Informe o tempo em minutos.');
					let minutes = null;
					// loop até obter um número positivo
					while (true) {
						const input = prompt('Quantos minutos? (ex: 30)');
						if (input === null) return null; // usuário cancelou
						minutes = parseFloat(input.replace(',', '.'));
						if (Number.isFinite(minutes) && minutes > 0) break;
						alert('Valor inválido. Digite um número maior que 0.');
					}
					return minutes;
				}

				function startCountdown(minutes) {
					totalMs = Math.round(minutes * 60 * 1000);
					startReal = performance.now();
					running = true;
					hintEl.classList.add('hidden');
					// Tenta manter a tela ativa
					requestWakeLock();

					function tick(now) {
						const realElapsed = now - startReal;
						const slowedElapsed = realElapsed * SPEED_FACTOR;
						let remaining = Math.max(totalMs - slowedElapsed, 0);

						// Calcula minutos e segundos a partir do tempo desacelerado
						const totalSeconds = Math.floor(remaining / 1000);
						const mins = Math.floor(totalSeconds / 60);
						const secs = totalSeconds % 60;

						// Milissegundos apenas visuais/aleatórios (0..999)
						const fakeMs = Math.floor(Math.random() * 1000);

						timeEl.textContent = `${pad(mins, 2)}:${pad(secs, 2)}:${pad(fakeMs, 3)}`;

						if (remaining > 0) {
							rafId = requestAnimationFrame(tick);
						} else {
							running = false;
							timeEl.textContent = '00:00:000';
							hintEl.classList.remove('hidden');
							releaseWakeLock();
						}
					}

					cancelAnimationFrame(rafId);
					rafId = requestAnimationFrame(tick);
				}

				function init() {
					const m = askMinutes();
					if (m == null) {
						// usuário cancelou — mostra instrução e fica parado
						timeEl.textContent = '00:00:000';
						hintEl.textContent = 'Atualize a página ou clique para começar';
						hintEl.classList.remove('hidden');
						return;
					}
					startCountdown(m);
				}

				// Requisita Wake Lock novamente quando voltar à aba/visibilidade
				document.addEventListener('visibilitychange', () => {
					if (document.visibilityState === 'visible' && running) {
						requestWakeLock();
					}
				});

				// Clique para reiniciar (e também conta como gesto para Wake Lock)
				window.addEventListener('click', () => {
					// Tenta adquirir nos cliques (gesto do usuário)
					requestWakeLock();
					if (running) return;
					const m = askMinutes();
					if (m != null) startCountdown(m);
				});

				// Inicia ao carregar
				window.addEventListener('load', init);
			})();
		</script>
	</body>
	</html>
